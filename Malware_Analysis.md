# Malware Analysis

### 컴파일시 나오는 .obj 파일이란?
* 코드 -> 전처리 -> 컴파일러 -> 어셈플러 -> 링커 -> 실행파일
	- 컴파일과정
* obj
	- PE
	- ELF(Executable and Linkable Format)
	- COFF
* __헤더와 섹션에 대한 정보가 담김__

### stub 코드
* 컴파일러가 보호기법(Mitigation)을 적용하기 위해, '전처리' 과정에 앞에 붙이는 코드
	- 컴파일러 마다 stub 코드가 다름
* zip파일 같은 패킹(packing)하는데 사용
	- 안티리버싱
* 컴파일러의 컴파일 방식이 들어감
#### 참고
* https://blue-shadow.tistory.com/20

#### Immunity Debugger
* 파이썬 개발
* 64bit 지원

#### 레지스터, 레지스트리
* 레지스터 : CPU 임시저장공간
* 레지스트리 : 저장소

### Jst-in-time debugging - OllyDbg
* error가 났을떼 처리 하는 옵션
* 컴퓨터에서 에러가 나연 OllyDbg에서 처리
	- Make OllyDbg Jst-in-time debugging 활성
	
### Debugging otions - OllyDbg
* Events - Entry point of main module 선택

#### ASLR : Address Space Layout Randomization
* 메모리 보호기법

---
#### CPU가 다르면 레지스터 정보도 바뀜

#### 안드로이드는 힙메모리 영역만 사용
* 스택 영역은 시스템만?

#### 메모리에서 메모리는 복사가 안됨 - 프로그램이 그렇게 됨
* 복사가 되면 메모리 복사

---
```
CF => Carry Flag
OF => Overflow Flag
SF => Sign Flag
ZF => Zero Flag
AF => Auximiliary carry Flag
PF => Parity Flag
DF => Direction Flag
IF => Interrupt Flag
TF => Trap Flag

CF => 부호없는 수 끼리 연산 후 연산결과가 길면 1
OF => 부호있는 수 끼리 연산 후 연산결과가 길면 1
SF => 연산결과가 음수면 1
ZF => 연산결과가 0이면 1
AF => 10진수 연산시 보정(자리올림, 빌림 등)이 필요하면 1
PF => 연산결과에서 1이 짝수개이면 1
DF => 문자열 처리할때 사용하는데 0이면 전진하면서 처리, 1이면 빽하면서 처리함
IF => 인터럽트 처리할때 사용하는데 0이면 외부에서들어오는 인터럽트 무시, 1이면 허용함
TP => 프로세서 처리할때 사용하는데 0이면 디폴트고 1이면 명령 실행후 특정 프로시저 호출

출처: https://mu1ti.tistory.com/16 [Multi]
```

### jump에서 'short'의 의미
* 참고 : https://stackoverflow.com/questions/5757866/what-does-short-jump-mean-in-assembly-language

---
## 함수 호출 규약
1. __cdecl
*  호출자가 최종 스택 프레임 반환 작업을 함(
	- caller가 스택 정리
* 장점 : 가변 길이 인자 전달 유용
* 표시 방식 : -

2. __stdcall
* 최종 스택 프레임 반환 작업을 피호출자가 함
	- Callee:호출을 받은 함수
* 장점 : 코드길이가 짧아짐
* 표시 방식 : -

3. __fastcall
* parameter들중 처음 2개 까지만 레지스터(ecx, edx)에 저장하고, 나머지는 스택에 푸쉬함
	- 스택 프레임 반환 작업은 피호출자(Callee)가 한다.
* 장점 : 빠른 함수 호출
* 표시 방식 : @

#### __cdecl과 __stcall은 언제 사용되어질까?
* __cdecl 호출 규약은 가변적인 인수의 개수를 위한 스택 연산이 가능
	- printf 등 C컴파일러에서 많이 사용함 
*가변 인자를 갖는 함수의 구현은 RET 명령어에서의 상수 인코딩시 스택 정리를 그에 맞게 변화 시키지 못하기 때문에 스택 정리의 책임을 호출하는 측에 맡기는 것이라고 함

---
`공유폴더 -> 문법별 샘플 코드`
* 파일들이 컴파일이 안 되면, example.zip 파일 사용
* 스튜디오 2019 실행 -> 새 프로젝트 만들기 -> 콘솔 앱(같은 디렉터리에 저장 체크)
	- 디버거는 'Release'로 실행하자
* 프로젝트 탭 -> 속성 ->
	- 고급 - 문자집합(유니코드 문자 집합 사용)
		+ 멀티바이트 : ASKII
	- 링커 -> 고급 - 임의 기준 주소(ASLR)(아니오), DEP(아니오)
		+ 위의 파일을 '아니오'하면 보안에 취약해짐
	- 링커 -> 매니페스트 파일 - UAC 사용(아니오)
		+ UAC를 우회하는 코드는 악성코드일 확률이 높음
	- C/C++ -> 최적화 - 최적화(사용 안 함)
		+ 최적화로 코드가 바껴 분석이 힘듬
	- C/C++ -> 코드 생성 - 런타밍 라이브러리(다중 스레드 DLL/MD), 보안 검사(보안 검사 사용 안 함)
		+ DLL를 사용하면 컴파일을할 때 내 프로그램에 포함하지 않음
		+ 스택가드(Stackguard), 카나리(canary)
		
* if.txt파일읗 컴파일해서 분석
 - 소스코드와 어셈블리 코드와 비교
 - 다른 '.txt' 파일도 비교

* 분석 샘플 코드 1풀기
	- Star_게임.iso.zip 숙제(시리얼 우회)

#### 뮤텍스(mutex)와 세마포어(semaphore)란?
* 참고 : https://artwook.tistory.com/17
* 뮤탄트(Mutant)는 상호 배제로 사용(일반 사용자, 커널 레벨에서 사용)
	- 뮤텍스는 커널 레벨

#### Pocess Explorer 다운로드
* 참고 : http://sysinternals.com/
	- process Utilitles -> Pocess Explorer

## 잡담 - 보안 솔루션 발달 과정
* binary signature > 패턴 매칭 > H-IDS == Anti Virus
	- IDS : 패턴 매칭(지속적인 패턴 업데이트) + 분석 방식(엔진이 좋음)
	
* DLP > C/S 구조 : agent -> server > 취합후 모니터링
	- 너무 많은 데이터를 취합(망작)

* SIEM > 응용프로그램 동작 -> 이벤트 발생을 추적 > 모니터링
	- SIEM(보안 정보 및 이벤트 관리)

* EDR > 응용프로그램 동작 -> 이벤트 발생 > __판단을 자동화 처리__ <-- ML, SSDeep(함수 유사도 평가)
	- 얼마나 신뢰할 수 있는가?
	- 대상
		+ 네트워크 패킷
		+ 바이너리
		+ 이벤트 로그에 따른 이상탐지
		
### Windows Mitigation
* 보안 기능을 사용하여 위협을 완화(Mitigation)
