# Network
* 두 대 이상의 컴퓨터(장치)가 연결된 상태

## 네트워크 기초 명령어
1. 네트워크 인터페이스 보는 명령어
* ipconfig
    - /all : MAC 주소 등 세부정보 확인
    - /release : ip 주소를 해제해서 네트워크 연결을 끊을 때
    - /renew : ip주소를 새롭게 갱신해서 네트워크 재연결
* ifconfig
* ip a s

###  NIC, 네트워크 인터페이스 카드 

2. netstat : 사용중인 port 정보 확인
    - a : 전체정보 표시
    - n : 포트정보를 번호를 표시
    - b : 프로세스 정보 표시

3. nslookup : dns 조회

4. ping : 상대방 호스트의 상태를 확인하기 위한 명령어
    - ICMP 프로토콜 사용한다.

5. tracert, traceroute : 네트워크 경로를 확인하기 위하여 사용함

6. arp : address resolution protocol
    - arp -a : arp 테이블(arp 캐시) 정보를 볼 수 있음

7. route print : 라우팅 테이블 정보
    - netstat -nr
* 메트릭 : 비용, 낮은 것을 선택
* rip, osrf, eigrp 자동으로 라우팅 경로를 세팅

8. hostname : 호스트 이름 확인

9. net user : 사용자 계정정보 확인

---
1비트 = 최소 단위
8비트 = 1바이트 = 처리 최소 단위

앞의 24비트는 OUI(제조사 고유정보)
뒤의 24비트는 각 NIC의 고유번호(HOST ID)

### 게이트웨이
* 서로 다른 프로토콜을 사용하는 네트워크끼리 통신할 수 있게 만듦

### 라우터
* 라우팅(최적의 경로 찾기)해주는 장비

---
### 동축 케이블
* 비쌈
* 무거윰
* 절연체가 두거움
    - 멀리까지 간섭 없이 연결 가능 

=================================
* 베이스 밴드
    - 디지털 신호 전송(LAN)
    - 변조하지 않음
    - 수백 미터(근거리 전송)
    - 양방향 통신
* 브로드 밴드
    - 아날로그 신호 전송(CATV)
    - 수십 킬로(장거리 전송)
    - 다중 채널(음성, 영상 등 따로 보냄)
    - 단방향 통신

=================================
### 네트둬크 패킷을 받는 경우
1. 유니캐스트인데 수신지가 나인 경우
2. 브로드캐스트 -> FF:FF:FF:FF:FF:FF , 255.255.255.255 
3. 멀티캐스트인데 내가 수신지에 적혀있는 멀티 캐스트 그굽에 속한 경우

* 패킷을 버리는 이유
    -  메모리와 CPU를 아끼기 위해

---
## 이더넷
* 2계층 통신 프로토콜
* Preamble 
    - 이더넷 헤더에 포함되지 않음
    - 이더넷 신호가 전송됨을 알림
```
10101010 * 7 + 10101011
10101011(SFD) : Start of Frame Delimeter)
```
* Destination Addresess : 도착지 MAC 주소 (6바이트)
* Source Addres : 출발지 MAC 주소 (6바이트)
* ethernet type : 상위 프로토콜 종류 (2바이트)
    - 0x0800 : IP
    - 0x0806 : ARP
* FCS : Frame Check Sequence : 오류 체크 값 (4byte)

이더넷 헤더의 길이 : 14바이트
이더넷 데이터의 길이  : 46바이트 ~ 1500바이트
이더넷 프레임의 최고 크기 : 1514(1518)

#### 라우터를 지날때 마다 목적지, 출발지 MAC주소도 바뀜

==================================
* wireshark
    - 패킷 캡처 프로그램
    - GUI 환경으로 패킷 분석


---
## 무선 네트워크

### IEEE 802.11 표준 규격
* 802.11ax(wifi6)    10GHz

---
## port
* 동일한 IP 주소를 가진 시스템 내에서 프로세스를 구분하기 위한 주소
    - 0 ~ 65535번 주소 사용, 16빈트 주소
    - 0 ~ 1023  : System Port(Well-known Port)
        + 잘 알려진 서비스들이 사용
    - 1024 ~ 49151 : User Port(Registerd Port)
        + 응용 프로그램들이 사용
    - 49152 ~ 56535 : Dynamic Port
        + 접속을 하는 용도로 사용

---
### 많이 알려진 서비스의 Port번호
* FTP : 20, 21 (File Transfer Protocol)  
* SSH : 22 (원격 접속, 암호화)  
* telnet : 23 (원격 접속, 비암호화)  
* SMTP : 25 (Simple Mail Transfer Protocol)  
* DNS : 53      UDP, TCP
* TFTP(Trivial FTP) : 69    UDP  
    - 스위치, 라우터 펨웨어 업데이트  
    - 간단한 자료 전송
* DHCP : 67 /UTP
* HTTP : 80 (평문 전송)
* HTTPS(SSL) : 443 (암호화 통신)
* pop3 : 110
* Netbios : 137 ~ 139 137 138   UDP, TCP
    - 윈도우 시스템 이름 관련 서비스
* SNMP : 161, 162 /UDP
    - TCP/IP 기반 네트워크상의 각 호스트로부터 정기적으로 여러 관리 정보를 자동으로 수집하거나 실시간으로 상태를 모니터링 및 설정할 수 있는 서비스
* SMB : 445 (파일 공유 프로토콜)

==========  
DBMS  
* MS-SQL : 1433, 1434  
* MY-SQL(MariaDB) : 3306  
* ORACLE : 1521  

* 원격 데스크톱 : 3389  


---
### 서비스 목목 확인
* windows\system32\drivers\etc\services
* /etc/services

---
## 와이어 샤크 사용법

### 화면 구성
* 패킷 리스트
* 패킷 디테일
* 패킷 바이트

### 패킷 검색 방법
```
ip.arr ==
ip.dst ==
ip.src ==

tcp.port == 80
udp.port == 80
tcp.dstport == 80
tcp.srcport == 80

|| : or
&& : and
```
실습 : 평문통신 http 프로토콜을 스니핑하기
* Promiscueous

---
## osi7 계층
참조 : https://shlee0882.tistory.com/110

* 7계층 - 응용 계층(Application Layer)
* 6계층 - 표현 계층(Presentation Layer)
    - 암호화, 복호화, 압축, 인코딩
    - 데이터 가공
* 5계층 -세션 계층(Session Layer)
    - 세션 연결, 유지, 해제
* 4계층 - 전송 계층(Transport Layer) 
    - 5계층과 4계층 사이에서 '포트' 연결/할당
    - 오류 복구, 흐름 제어 등 담당
* 3계층 - 네트워크 계층(Network Layer)
    - IP
* 2계층 - 데이터 링크계층(DataLink Layer)
* 1계층 - 물리계층(Physical Layer)

### PDU(Protocol Data Unit)
* 프로토콕 전송 단위
    - 전송계정 : 세그먼트
    - 네트워크 : 패킷
    - 데이터 링크 : 프레임
* DPI(deep packet inspection)
    - 패킷을 깊게 분석함

---
## 네트워크 장비
* hub
    - Flooding
    - Collision(충돌)
* Swithc L2
    - Collision domain(충돌이  일어나는 범위)
    - Learning : 스위치의 MAC Address Table에 각 포트에 해당하는 MAC Address를 학습
    - Forwarding : 목적지를 앎
        + MAC Address Table을 참고하여 전송할 패킷이 전달되어야 할 포트로만 전송
    - Filtering : 목적지 이외에는 안 보냄
        + MAC Address Table을 참고하여 전송될 필요가 없는 포트로는 전송을 하지 않음
    - Flooding : 목적지를 모름
        + 목적지 MAC Address를 모르는 패킷은 전체 포트로 전달, 그외 브로드 캐스트 패킷도 전체 포트로 전달
    - Aging : MAC Table 캐싱 시간(300초)
        + 약 300초 정도 MAC Address Table 유지 : 300초 내 갱신이 없을 경우 MAC Address Table 삭제, 갱신이 있을 경우 시간 연장
        + 리소스를 아낌, 장비 변경 가능성

* Router, L3 Swithch
* L4 Switch
* L7 Switch

#### 브로드캐스트 도메인 : 브로드캐스트 범위

---
## IP
* IP 주소 체계
    - IP 주소는 Network ID와 Host ID로 구분된다.
* Network ID가 같다는 것은 같은 네트워크에 속한다.
* 클래스 : IP주소를 효율적으로 배정하기 위한 개념

A클래스 : 0.0.0.0 ~ 127.255.255.255
B클래스 : 128.0.0.0 ~ 191.255.255.255
C클래스 : 192.0.0.0 ~ 223.255.255.255 
D클래스 : 224.0.0.0 ~ 239.255.255.255
E클래스 : 240.0.0.0 ~ 255.255.255.255

### 서브넷  마스크
    - 서브넷팅하는데 사용하는 수단, 해당 네트워크의 Network ID와 Host ID 구

============================     
#### A클래스의 넷마스크
* 255.0.0.0

#### A클래스 네트워크 개수
* 128개
    - 다만 0과 127로 시작하는 네트워크는 제외
    - 나눠줄 수 있는 네트워크 개수는 126개

#### A클래스 호스트 개수
* 256 * 256 * 256 = 16777216개
    - 전체 IP갯수에서 2개를 빼야함
    - 16777214 개
* 가장 맨 처음 호스트 주소
    - 호스트 주소가 모두 0인 주소, 네드워크 주소
* 가장 맨 끝 호스트 주소
    - 호스트주소가 모두 1인 주소, 브로드 캐스트 주소

네트워크 주소 : 하나의 네트워크를 통칭하는 주소(대표자)
브로드캐스트 주소 : 특정 네트워크에 속하는 모든 호스트들이 듣게되는 주소(모두)

--------------------------------------------------------------
### 서브넷마스크 예시
```
192.168.0.10  둘다 서브넷마스크 255.255.255.128
192.168.0.148

이 두개의 ip는 같은 네트워크에 속하는가? 다름

대상 ip에 서브넷마스크를 bit 연산하여 네트워크 id 가 같으면 같은 네트워크

11000000.10101000.00000000.00001010  192.168.0.10

11111111.11111111.11111111.11111100  255.255.255.255

11000000.10101000.00000000.00000000   and 연산

-----------------------------------------------------------------------
11000000.10101000.00000000.10010100    192.168.0.148

11111111.11111111.11111111.10000000  255.255.255.128

11000000.10101000.00000000.10000000   and 연산
```
============================     
#### B클래스의 넷마스크
* 255.255.0.0

#### B클래스 네트워크 개수
* 2^14 = 16384개

#### B클래스 호스트 개수
* 2^16 = 65536개 - 2개 = 65534개

퀴즈 : 150.20.0.0 ~ 150.20.255.255

         네트워크 주소 :  150.20.0.0
         브로드캐스트 주소 : 150.20.255.255

실제 사용가능한 주소 범위 : 150.20.0.1 ~ 150.20.255.254

============================     
#### C클래스의 넷마스크
* 255.255.255.0

#### C클래스 네트워크 개수
* 2^21 =2097152개

#### C클래스 호스트 개수
* 256개 - 2 = 254개

예 : 192.168.0.0 ~ 192.168.0.255

네트워크 주소 : 192.168.0.0
브로드캐스트주소 : 192.168.0.255
실제 사용가능한 ip 주소 : 192.168.0.1~ 192.168.0.254

============================     
#### D클래스
* 멀티 캐스트 주소로 씀

============================
#### E클래스
* 예약용

---
### 서브넷팅
* 네트워크를 반복적으로 1/2로 분할해서 구해보자

prefix 표기법

CIDR = 슈퍼넷팅 + 서브넷팅 + prefix

-------------------------------------------------------------

서브넷팅 예제

1. 211.100.10.0 ~ 211.100.10.255의 C클래스 네트워크를 네트워크당 60개의 IP를 사용가능하도록 서브네팅 해보자.

1) 서브넷 마스크는?

/26        255.255.255.192

211.100.10.0/26
211.100.10.64/26
211.100.10.128/26
211.100.10.192/26

2) 서브넷의 개수는? 4개
3) 네트워크당 ip의 개수는? 64, 62
4) 첫번째 서브넷의 브로드캐스트 주소는 어떻게 되는가 ? 211.100.10.63
5) 두번째 서브넷의 사용가능한 ip 범위는 어떻게 되는가?
     211.100.10.65  ~  211.100.10.126

2. 211.100.10.0 ~ 211.100.10.255의 C클래스 네트워크를 네트워크당 13개의 IP를 사용가능하도록 서브네팅 해보자.

1) 서브넷 마스크는?  255.255.255.240
2) 서브넷의 개수는?  16개
3) 네트워크당 사용가능한 ip의 개수는?   14개
4) 첫번째 서브넷의 브로드캐스트 주소는 어떻게 되는가 ?  211.100.10.15
5) 두번째 서브넷의 사용가능한 ip 범위는 어떻게 되는가?
211.100.10.17  ~   30

3. B클래스 크기의 네트워크를 서브네팅 해보자
네트워크 주소가 151.92.0.0인 B클래스 네트워크를 각 네트워크당 6500개의 ip가 사용 가능하도록 서브네팅 해보자

서브넷마스크는?         255.255.224.0      /19 
서브넷당 사용가능한 ip의 개수는 어떻게 되는가?  8190개
서브넷의 갯수는 어떻게되는가  8개
서브넷의 네트워크 주소를 모두 나열해보자

151.92.0.0/19
151.92.32.0/19
151.92.64.0/19
151.92.96.0/19
.......
/19      ->      8192     255.255.224.0
/20      ->     4096      255.255.240.0
/21    ->        2048      255.255.248.0
/22      ->     1024    255.255.252.0
/23      ->      512     255.255.254.0
/24       ->     254     0 
/25       ->     126   128
/26       ->      62    192
/27      ->       30     224
/28       ->      14     240

==================  
VLSM(Variable Length Subnet Mask)
* 서브넷을 여러번 수행
* 계산방식 : 가장 큰 네트워크부터 할당, 남은 네트워크를 서브네팅

서브네팅
```
192.168.100.0 /24 
192.168.100.0    /26   62개    -> 60
192.168.100.64   /26   62개    -> 30
192.168.100.128  /26   62개    -> 10

192.168.100.192  /26

---------------------------------  
VLSM
192.168.100.0 /24
192.168.100.0    /26   62개    -> 60
192.168.100.64   /27   30개    -> 30
192.168.100.96  /28    14개    -> 10

192.16.100.112 ~

-----------------------------------------------
문제 1 :
201.102.1.0/24 네트워크를 1팀 120개, 2팀 60개, 3팀, 4팀 각 20개씩 네트워크로
VLSM 서브네팅을 해보시오

각 팀별로 네트워크 주소/prefix 방식으로 표기

1팀 : 201.102.1.0/25
2팀 : 201.102.1.128/26
3팀   201.102.1.192/27
4팀   201.102.1.224 /27


문제 2 : 133.200.0.0/16 네트워크를 다음과 같은 개수로 할당해보시오.

22   25   230  500  1000   2400   3500   4000


4000           133.200.0.0/20
3500           133.200.16.0/20
2400           133.200.32.0/20
1000           133.200.48.0/22
500             133.200.52.0/23
230             133.200.54.0/24
25               133.200.55.0/27
22              133.200.55.32/27
------------------------------------------------
```

---
### IP주소 부족을 극복하기 위한 방법
1. IPv6 주소체계 - 128 bit 주소 길이를 사용
2. 사설 네트워크 + NAT(Network address Translation)
3. 서브넷 : 네트워크를 쪼개는 기술
4. DHCP : Dynamic Host Configuration Protocol

#### 사설 네트워크 아이피 대역
* 10.0.0.0 ~ 10.255.255.255 A쿨래스
* 172.16.0.0 ~ 172.31.255.255 B클래스
* 192.168.0.0 ~ 192.168.255.255 C클래스

* 공인 아이피 확인 : https://findip.kr/

---
## 각 프로토콜 분석(IP, TCP, ARP, ICMP, UDP, ...)

### IP
IP 헤더 20 바이트

* version: ipv4, ipv6 등 ip 버전 확인용
    - 4bit
* IHL : IP Header Length 헤더 길이/4 값이 저장
    - 일반적으로 5가 저장됨
    - 4bit
* TOS : Type of Service
    - 거의 사용되는 않음. QOS와 관련됨
    - 8bit(1Byte)
* Total Length : IP 패킷 총 길이
    - IP헤더 길이 + 데이터 길이
    - 16bit(2Byte)
* Identification : 단편화된 조각을 구분하기 위한 구분자
    - 16bit(2Byte)
    - 단편화되면 번호가 같음
* IP FLAGS : 단편화 옵션
    - 3bit
    - x : 안씀
    - D : Do not frag   0이면 단편화
    - M : More frag     0이면 단편화 없음
* Fragment offset : 단편화된 조각 위치
    - 13bit 
```
오프셋  길이    이더넷헤더    IP헤더    데이터
0       1514    14          20        1480
1480    1514
2960    154
```
* TTL(Time to Live) : 네트워크에서 패킷의 수명
    - 리눅스 : 64
    - 윈도우 : 128
    - 네트워크장비(cisco) : 255
    - 8bit(1Byte)
* protocol
    - 8bit(1Byte)
    - 01 : ICMP
    - 06 : TCP
    - 17 :  UDP
* Header checksum : 헤더에 에러가 있는지 체크
    - 16bit(2Byte)
* 보내는 주소
    - 32bit(4Byte)
* 받는 주소
    - 32bit(4Byte)
* 기타 옵션
    - IP 전달에 걸린 시간 값, 라우터에 특별한 명령

---
### TCP, UDP
* TCP 
    - 연결지향형 프로토콜
    - 안정적인 전송이 목표
    - 윈도우사이즈 설정을 통해 흐름을 제어
    - 긴 데이터 전송에 적합
    - 대부분의 응용프로그램에서 사용
* UDP 
    - 비연결지향형 프로토콜
    - 단순하고 빠른 전송
    - 흐름 제어 불가
    - 짧은 데이터 전송에 적합
    - DNS, DHCP, SNMP, TFTP, ...

==========================================
#### TCP 헤더 분석
* 출발 포트
    - 16bit(2Byte)
* 도착 포트
    - 16bit(2Byte)
* Sequence number
* Acknowledgment number
```
seq ack의 통신 방법
1. 보내는 쪽은 임의의 숫자를 지정하여 자신의 seq를 생성
2. 데이터를 송신후 자신의 seq값에 보낸 데이터 양만큼의 숫자를 증가시킴
3. 받는 쪽에서는 전송박은 seq와 데이터 양을 확인하고 ack값을 계산해서 응답으로 보냄
4. ack는 전송받은 데이터의 양을 표시
```
3way handshake
1. 클라이언트가 서버에게 연결 시도 : SYN Flag
2. 서버가 클라이언트에게 연결 허용 알림 : SYN+ACK Flag
3. 클라이언트가 수신 확인 전송 : ACK Flag

4way Handshake
1. 연결을 끊고자 하는 쪽에서 연결 종료 시도 : FIN+ACK Flag
2. 상대방에서 연결종료신호 수신 확인 : ACK Flag
3. 상대방도 연결종료 시도 : FIN+ACK Flag
4. 연결을 끊는 쪽에서도 연결종료 수신 확인 : ACK Flag

* Header Length : 일반적으로 5(0x0101) 값이 들어감
    - 4bit
    - 5 * 4 =20
* Reserved 필드(3bit)
    -차후의 사용을 위해서 예약된  3비트 필드
* TCP Flags
    - 9bit - 6bit만 사용
    - N : NS  : '참고 링크' 참조
    - C : CWR : 사용안함
    - E : ECE : 사용안함
    ---
    - U : URG : 긴급한 데이터가 있을 경우 사용
    - A : ACK : 데이터 수신 확인
    - P : PSH : 보내는 데이터를 버퍼에 저장하지 않고 바로 전달
    - R : RST : 연결이 비정상일 경우 연결 재수립 요청, SYN에 대한 거부의 의미로도 쓰임
    - S : SYN : 연결 수립할 때
    - F : FIN : 연결 종료
* Window Size : 호스트가 수신할 수 있는 버퍼 사이즈
    - 흐름 제어 : 호스트가 알려주는 버퍼크기에 맞춰 속도 조절
    - 16bit(2Byte)
* Checksum : 오류 체크 (데이터, 헤더)
    - 16bit(2Byte)
* Urgent Pointer : 긴급 데이터의 위치를 알려주는 값(긴급 데이터의 크기, 끝나는 위치)
* 옵션 : 세그먼트 크기, 타이스탬프 값 등등등

참고 : https://evan-moon.github.io/2019/11/10/header-of-tcp/

==========================================
#### TDP 헤더 분석
* 출발 포트
    - 16bit(2Byte)
* 목적 포트
    - 16bit(2Byte)
* Length : 전체길이
    - 16bit(2Byte)
    - 최소값: 8
* checksum : 오류 체크
    - 16bit(2Byte)

## RFC 
* 네트워크 공식 규격 문서

---
### ARP
* IP Address 정보를 가지고 MAC Address 정보를 알아오는 프로토콜

#### ARP의 MAC 주소 찾는 법
1. 대상을 찾기 위해 IP 주소에 해당하는 MAC Address를 ARP로 요청
    - 브로드캐스트
2. 해당 ip를 가지고 있는 호스트는 ARP 요청을 전송한 호스트에게 ARP 응답을 전송함
    - 유니캐스트

#### ARP 헤더 분석
* Harware Type : 2계층 프로토콜 타입
    - 1 : Ethernet
    - 16bit(2Byte)
* Protocol Type : 3계층 프로토콜 타입
    - 0x800(2048)(IPv4)
    - 16bit(2Byte)
* Hardware Address Length : MAC Addresss의 길이
    - 6
    - 4bit(1Byte)
* Protocol Address Length : IP Address의 길이
    - 4
    - 4bit(1Byte)
* OPCODE
    - 1 : ARP 요청
    - 2 : ARP 응답
    - 3 : RARP 요청
    - 4 : RARP 응답
    - 5 : 다른 종류 ARP 요청/응답
    - 16bit(2Byte)
    - RARP -> bootp -> DHCP 변천사
* Sender Hardware Address
    - 48bit(6Byte)
* Sender Protocol Address
    - 32bit(4Byte)
* Target Hardware Address
    - 48bit(6Byte)
* Target Hardware Address
    - 32bit(4Byte)

---
### ICMP